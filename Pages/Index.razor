@page "/"

@using System.Drawing
@using System.Timers
@using GoRogue.MapGeneration
@using GoRogue.MapViews;
@using Troschuetz.Random.Generators
@inject IJSRuntime JSRuntime

<div tabindex="0" class="container-fluid game-field" @onkeydown=KeyDown @ref="gameFieldDiv">
    <div class="row justify-content-center game-info">
        <div>Health: @Health</div>
        &nbsp;|&nbsp;
        <div>Score: @Score</div>
    </div>
    @for (int y = ViewPort.Y; y < ViewPort.Height; y++)
    {
        <div class="row justify-content-center">
            @for (int x = ViewPort.X; x < ViewPort.Width; x++)
            {
                if (PlayerLocation.X == x && PlayerLocation.Y == y)
                {
                    <span class="player"></span>
                    continue;
                }

                <span class=@(GetTileClassName(x, y))></span>
            }
        </div>
    }
</div>

@code
{
    private int Health = 50;
    private int Score = 0;
    private const int CoinValue = 50;
    private const int PotionValue = 25;
    private int TotalNumberOfCoins = 150;
    private int TotalNumberOfPotions = 50;
    private Random random = new Random();
    private List<Point> CoinLocations = new List<Point>();
    private List<Point> PotionLocations = new List<Point>();
    private List<Point> EnemyLocations = new List<Point>();
    private ElementReference gameFieldDiv;
    private Point PlayerLocation;
    private int ViewPortHeight = 12;
    private int ViewPortWidth = 25;
    private Rectangle ViewPort;
    private const int WIDTH = 150;
    private const int HEIGHT = 150;
    private int[,] gameMap = new int[HEIGHT, WIDTH];
    private int[,] lightMap = new int[HEIGHT, WIDTH];

    private void UpdatePlayerViewPortPoints(Point PlayerLocation)
    {
        int viewPortX = PlayerLocation.X - ViewPortWidth;
        int viewPortY = PlayerLocation.Y - ViewPortHeight;

        if (viewPortX < 0) viewPortX = Math.Max(0, viewPortX);
        if (viewPortX > (WIDTH - (ViewPortWidth * 2))) viewPortX = (WIDTH - (ViewPortWidth * 2));

        if (viewPortY < 0) viewPortY = Math.Max(0, viewPortY);
        if (viewPortY > (HEIGHT - (ViewPortHeight * 2))) viewPortY = (HEIGHT - (ViewPortHeight * 2));

        int viewPortWidth = viewPortX + (ViewPortWidth * 2);
        int viewPortHeight = viewPortY + (ViewPortHeight * 2);

        ViewPort = new Rectangle(viewPortX, viewPortY, viewPortWidth, viewPortHeight);

        lightMap = FOV();
    }

    protected override void OnInitialized()
    {
        gameMap = GenerateMapWithRectangularRooms(WIDTH, HEIGHT, 35, 4, 15);
    
        UpdatePlayerViewPortPoints(PlayerLocation);

        SpawnCoins();
        SpawnPotions();

        var timer = new Timer(1000);
        timer.Elapsed += new ElapsedEventHandler(GameLoop);
        timer.Enabled = true;
    }

    private int[,] GenerateMapWithRectangularRooms(int width, int height, int maxRooms, int roomMinSize, int roomMaxSize)
    {
        var map = new ArrayMap<bool>(width, height);
        QuickGenerators.GenerateRandomRoomsMap(map, new StandardGenerator(), maxRooms, roomMinSize, roomMaxSize, 5);

        var result = new int[height, width];

        for (int y = 0; y < map.Height; y++)
        {
            for (int x = 0; x < map.Width; x++)
            {
                if (map[x, y])
                {
                    result[y, x] = 2;

                    if(PlayerLocation.IsEmpty)
                    {
                        PlayerLocation = new Point(x, y);
                    }
                }
                else
                {
                    result[y, x] = 1;
                }
            }
        }

        return result;
    }

    private Point GenerateRandomPoint()
    {
        int h = 0;
        int w = 0;

        do
        {
            h = random.Next(0, HEIGHT - 1);
            w = random.Next(0, WIDTH - 1);
        }
        // We are only checking to see if the tile is a wall and now if we
        // already placed some other object. FIX ME LATER!
        while (gameMap[h, w] == 1);

        return new Point(w, h);
    }

    private void SpawnPotions()
    {
        if (PotionLocations.Count() == 0)
        {
            for (int i = 0; i < TotalNumberOfPotions; i++)
            {
                PotionLocations.Add(GenerateRandomPoint());
            }
        }
    }

    private void SpawnCoins()
    {
        if (CoinLocations.Count() == 0)
        {
            for (int i = 0; i < TotalNumberOfCoins; i++)
            {
                CoinLocations.Add(GenerateRandomPoint());
            }
        }
    }

    private void GameLoop(object source, ElapsedEventArgs e)
    {
        // TODO: Do some game updates here...
    }

    private int[,] InitializeMap()
    {
        int[,] map = new int[HEIGHT, WIDTH];

        for (int height = 0; height < HEIGHT; height++)
            for (int width = 0; width < WIDTH; width++)
            {
                map[height, width] = 0;
            }

        return map;
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("SetFocusToElement", gameFieldDiv);
        }
    }

    private void UpdateAfterPlayerMoved()
    {
        var coin = CoinLocations.FirstOrDefault(p => p.X == PlayerLocation.X && p.Y == PlayerLocation.Y);

        if (!coin.IsEmpty)
        {
            Score += CoinValue;
            CoinLocations.Remove(coin);
        }
        else
        {
            var potion = PotionLocations.FirstOrDefault(p => p.X == PlayerLocation.X && p.Y == PlayerLocation.Y);

            if (!potion.IsEmpty)
            {
                Health += PotionValue;
                PotionLocations.Remove(potion);
            }
        }

        lightMap = FOV();
    }

    private void KeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "ArrowUp")
        {
            if (gameMap[PlayerLocation.Y - 1, PlayerLocation.X] != 1)
            {
                PlayerLocation.Y -= 1;
                UpdateAfterPlayerMoved();
                UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowDown")
        {
            if (gameMap[PlayerLocation.Y + 1, PlayerLocation.X] != 1)
            {
                PlayerLocation.Y += 1;
                UpdateAfterPlayerMoved();
                UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowLeft")
        {
            if (gameMap[PlayerLocation.Y, PlayerLocation.X - 1] != 1)
            {
                PlayerLocation.X -= 1;
                UpdateAfterPlayerMoved();
                UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowRight")
        {
            if (gameMap[PlayerLocation.Y, PlayerLocation.X + 1] != 1)
            {
                PlayerLocation.X += 1;
                UpdateAfterPlayerMoved();
                UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
    }

    private string GetTileClassName(int x, int y)
    {
        if (x >= WIDTH) x = WIDTH - 1;
        if (y >= HEIGHT) y = HEIGHT - 1;

        if (@lightMap[y, x] == 2)
        {
            if (CoinLocations.Any(p => p.X == x && p.Y == y))
            {
                return "coin";
            }

            if (PotionLocations.Any(p => p.X == x && p.Y == y))
            {
                return "potion";
            }

            if (gameMap[y, x] == 1)
            {
                return "wall";
            }
            else if (gameMap[y, x] == 2)
            {
                return "grass";
            }
        }

        return "hidden";
    }

    // Taken from http://www.roguebasin.com/index.php?title=Eligloscode
    // Modified to fit in my game
    private int[,] FOV()
    {
        float x, y;
        int i;

        int[,] map = InitializeMap();

        for (i = 0; i < 360; i++)
        {
            x = (float)Math.Cos(i * 0.01745f);
            y = (float)Math.Sin(i * 0.01745f);
            DoFov(x, y, map);
        };

        return map;
    }

    private void DoFov(float x, float y, int[,] map)
    {
        int i;
        float ox, oy;
        ox = (float)PlayerLocation.X + 0.5f;
        oy = (float)PlayerLocation.Y + 0.5f;

        for (i = 0; i < 25; i++)
        {
            map[(int)oy, (int)ox] = 2;
            if (gameMap[(int)oy, (int)ox] == 1) // if tile is a wall
                return;
            ox += x;
            oy += y;
        };
    }
}
