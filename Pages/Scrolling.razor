@page "/scrolling"
@using System.Drawing
@inject IJSRuntime JSRuntime

<div tabindex="0" class="container-fluid game-field" @onkeydown=KeyDown @ref="gameFieldDiv">
    @for (int y = ViewPort.Y; y < ViewPort.Height; y++)
    {
        <div class="row">
            @for (int x = ViewPort.X; x < ViewPort.Width; x++)
            {
                if (PlayerLocation.X == x && PlayerLocation.Y == y)
                {
                    <span class="player"></span>
                    continue;
                }

                <span class=@(GetTileClassName(x, y))></span>
            }
        </div>
    }
</div>

@code
{
    private ElementReference gameFieldDiv;
    private Point PlayerLocation = new Point { X = 5, Y = 5 };
    private int ViewPortHeight = 10;
    private int ViewPortWidth = 10;
    private Rectangle ViewPort;
    private const int WIDTH = 30;
    private const int HEIGHT = 30;
    private int[,] gameMap = new int[HEIGHT, WIDTH];

    private async Task UpdatePlayerViewPortPoints(Point PlayerLocation)
    {
        int viewPortX = PlayerLocation.X - ViewPortWidth;
        int viewPortY = PlayerLocation.Y - ViewPortHeight;

        if (viewPortX < 0) viewPortX = Math.Max(0, viewPortX);
        if (viewPortX > (WIDTH - (ViewPortWidth * 2))) viewPortX = (WIDTH - (ViewPortWidth * 2));

        if (viewPortY < 0) viewPortY = Math.Max(0, viewPortY);
        if (viewPortY > ViewPortHeight) viewPortY = ViewPortHeight;

        int viewPortWidth = viewPortX + (ViewPortWidth * 2);
        int viewPortHeight = viewPortY + (ViewPortHeight * 2);

        ViewPort = new Rectangle(viewPortX, viewPortY, viewPortWidth, viewPortHeight);

        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnInitializedAsync()
    {
        await UpdatePlayerViewPortPoints(PlayerLocation);

        var random = new Random();

        for (int height = 0; height < HEIGHT; height++)
            for (int width = 0; width < WIDTH; width++)
            {
                if (height == 0 || width == 0 || height == HEIGHT - 1 || width == WIDTH - 1)
                {
                    gameMap[height, width] = 1;
                }
                else
                {
                    var flip = random.Next(0, 100);

                    if(flip <= 15 && height != PlayerLocation.Y && width != PlayerLocation.X)
                    {
                        gameMap[height, width] = 1;
                    }
                    else
                    {
                        gameMap[height, width] = 2;
                    }
                }
            }
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("SetFocusToElement", gameFieldDiv);
        }
    }

    private async Task KeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "ArrowUp")
        {
            if (gameMap[PlayerLocation.Y - 1, PlayerLocation.X] != 1)
            {
                PlayerLocation.Y -= 1;
                await UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowDown")
        {
            if (gameMap[PlayerLocation.Y + 1, PlayerLocation.X] != 1)
            {
                PlayerLocation.Y += 1;
                await UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowLeft")
        {
            if (gameMap[PlayerLocation.Y, PlayerLocation.X - 1] != 1)
            {
                PlayerLocation.X -= 1;
                await UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
        else if (args.Key == "ArrowRight")
        {
            if (gameMap[PlayerLocation.Y, PlayerLocation.X + 1] != 1)
            {
                PlayerLocation.X += 1;
                await UpdatePlayerViewPortPoints(PlayerLocation);
            }
        }
    }

    private string GetTileClassName(int x, int y)
    {
        if(x >= WIDTH) x = WIDTH - 1;
        if(y >= HEIGHT) y = HEIGHT - 1;

        if (gameMap[y, x] == 1)
        {
            return "wall";
        }
        else if (gameMap[y, x] == 2)
        {
            return "grass";
        }

        return "hidden";
    }

}
